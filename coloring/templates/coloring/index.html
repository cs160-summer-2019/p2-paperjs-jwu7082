{% load static %}

<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>P3 Coloring</title>
  
	<script type="text/javascript" src="{% static 'coloring/vendors/jquery/jquery-3.3.1.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'coloring/vendors/jquery-ui/jquery-ui.min.js' %}"></script>
  
	<script type="text/javascript" src="{% static 'coloring/vendors/paper/paper-full.min.js' %}"></script>
  
  <script type="text/javascript" src="{% static 'coloring/vendors/hammer/hammer.min.js' %}"></script>
	<script type="text/javascript" src="{% static 'coloring/vendors/hammer/jquery.hammer.js' %}"></script>
  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/TweenMax.min.js"></script>
  
  <link rel="stylesheet" type="text/css" href="{% static 'coloring/vendors/normalize.css' %}" />
  <link rel="stylesheet" type="text/css" href="{% static 'coloring/vendors/bootstrap/css/bootstrap.css' %}" />
	<link rel="stylesheet" type="text/css" href="{% static 'coloring/css/style.css' %}" />
  
  
  <!-- TODO: REDO PALETTE. Add separate CSS file and modify div in HTML body -->
	<style type="text/css">

    .body { 
      margin: 0;
      padding: 0;
    }

		#color-palette {
      z-index: 2;
			width: 300px;
			background-color: #f1f1f1;
			display: flex;
			flex-wrap: wrap;
			position: absolute;
			top: 0;
		}

		.swatch {
			width: 24px;
			height: 24px;
			-moz-border-radius: 12px;
			-webkit-border-radius: 12px;
			border-radius: 12px;
			margin: 3px;
		}
    
 		#myCanvas {
      z-index: 5;
     position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: block;
/*       overflow: hidden; */ 
      background-color: blueviolet; /* for testing purposes */
      background-color: transparent;
/*       width: 100%; */
		}
	</style>
 
  
	<script type="text/javascript" canvas="canvas">
      window.onload = function() {
			var canvas = document.getElementById('myCanvas');
       
      // ZOOM FUNCTIONALITY USING HAMMER.JS 
        // TODO: PREVENT COLORING WHEN ZOOMING! 
        // TODO: CHANGE ZOOM TO PTR LOCATION NOT CENTER?
      var pinchHammer = new Hammer(document.getElementById('myCanvas'));
      pinchHammer.get('pinch').set({ enable: true }); // disabled by default
      pinchHammer.on('pinch', function(e) {
        if (e.scale >= 1) {
         // $('#myCanvas').css('transform', 'scale(' + e.scale + ')');
            paper.view.zoom = e.scale;
         }
      });
        
      // PAN FUNCTIONALITY USING HAMMER.JS
      // Requires 2 fingers. Combined with zoom. 
//       var panHammer = new Hammer(document.getElementById('myCanvas'));
//       panHammer.get('pan').set({ direction: Hammer.DIRECTION_ALL, threshold: 0, pointers: 2 });
//       panHammer.on('pan', function(e) {
//         if (e.scale > 1) {
//          $('#myCanvas').css('transform', 'translate(' + e.deltaX + 'px,' + e.deltaY + 'px)');
//         }
//       });


			// coloring page
			var mandala = {
				item: null,
				lastClicked: null,
				filePath: '/static/coloring/images/mandala-freepik.svg'
			};
     
			// color palette
			var cp = {
				history: ["#000000"], // black selected by default
				options: [],
				$container: $('#color-palette')
			}

			// your rectangle gradient interaction goes in this function
			// you may also add code outside of the function (e.g., global variables)
			// http://paperjs.org/tutorials/interaction/mouse-tool-events/
			function myGradientInteraction() {
				var tool = new paper.Tool();
				var start;
				var end;
				// Create red rectangle
				// http://paperjs.org/tutorials/paths/creating-predefined-shapes/
				var rectangle = new paper.Rectangle(new paper.Point(150, 250), new paper.Point(485, 450));
				var path = new paper.Path.Rectangle(rectangle);
				path.fillColor = 'red';
				path.closed = true;
				paper.view.draw();

				tool.onMouseDown = function(event) {
					// Set origin of gradient at mouse-down location
					start = event.point;
				}

				tool.onMouseUp = function(event) {
					// Set destination of gradient at mouse-up location
					end = event.point;

					// Set rectangle fillColor to gradient
					path.fillColor = {
						gradient: {
							stops: [cp.history[cp.history.length-2], cp.history[cp.history.length-1]]
						},
						origin: start,
						destination: end
					};
				}
			}

			// your custom interaction goes here!
			function myCustomInteraction() {
				var tool = new paper.Tool();
        var path;
        tool.fixedDistance = 30;
        
        /* SOLID COLOR FILL */
				tool.onMouseDown = function(event) {
				    var hit = mandala.item.hitTest(event.point, { tolerance: 10, fill: true });
				    if (hit) {
				        hit.item.fillColor = cp.history[cp.history.length - 1];
				    }
				}
        
        
        /* MODIFY THIS SO THAT MARKER/PEN IS ONLY USED TO ADD TO/CREATE OWN OUTLINES */
//         /* MARKER */
//         // http://paperjs.org/tutorials/interaction/working-with-mouse-vectors/#adding-brush-stroke-ends
//         tool.onMouseDown = function(event) {
//           var hitOptions = { fill: true, tolerance: 1 };
//           var hitResult = mandala.item.hitTest(event.point, hitOptions);
          
//           // TODO: FIX/DELETE 
//           if (hitResult) {
//             path = hitResult.item;
//           } else {
//             path = new paper.Path();
//           }
          
//           // TODO: add a new path inside hitResult.item.
// //           if (hitResult) {
// //             path = new paper.Path();
// //             hitResult.addChild
// //             path.add(hitResult.item.hitTest.point); 
// //           }
       
//           // path.fillColor = { hue: Math.random() * 360, saturation: 1, brightness: 1 };
//           path.fillColor = cp.history[cp.history.length - 1];
//         }

//         tool.onMouseDrag = function(event) {
//           var step = event.delta / 2;
//           step.angle += 90;
//           var top = event.middlePoint + step;
//           var bottom = event.middlePoint - step;
//           path.add(top);
//           path.insert(0, bottom);
//         }

//         tool.onMouseUp = function(event) {
//           path.closed = true;
//         }
        
        /* WATERCOLOR */
        // TODO
    }

/* ======= TODO: REDO PALETTE. Add separate CSS file and modify div in HTML body ======= */
			// create a color palette with the given colors
			function createColorPalette(colors) {
				// create a swatch for each color
				for (var i = colors.length - 1; i >= 0; i--) {
					var $swatch = $("<div>").css("background-color", colors[i]).addClass("swatch");
					$swatch.click(function() {
						// add color to the color palette history
					  	cp.history.push($(this).css("background-color"));
					});
					cp.$container.append($swatch);
				}
			}

			// loads a set of colors from a json to create a color palette
			function getColorsCreatePalette() {
				cp.$container.html(" ");
				$.getJSON('/static/coloring/vendors/material/material-colors.json', function(colors) {
					var keys = Object.keys(colors);
					for (var i = keys.length - 1; i >= 0; i--) {
						cp.options.push(colors[keys[i]][500]);
					}
					createColorPalette(cp.options);
				});
			}

			function init(custom) {
				paper.setup(canvas);
				getColorsCreatePalette();
				paper.project.importSVG(mandala.filePath, function(item) {
					mandala.item = item._children["design-freepik"];
				    paper.project.insertLayer(0, mandala.item);
				    if (custom) {
				    	myCustomInteraction();
				    } else {
				    	myGradientInteraction();
				    }
				});
			}
			// To see your myGradientInteraction version visit http://<your url>:8000/coloring/?type=gradient
			// To see your myCustomInteraction version visit http://<your url>:8000/coloring/
			var url = window.location.href;
			if (url.indexOf("gradient") > -1) {
				init(false);
			} else {
				init(true);
			}
		
    
    // SOURCE: https://codepen.io/shshaw/pen/zPxMgd
    $(document).ready(function() {
        console.clear();
        var twoPI = 2 * Math.PI;
        var canvas = document.createElement('canvas'),
//         var canvas = document.getElementById('myCanvas'), // MODIFICATION
            ctx = canvas.getContext('2d');
        var width = canvas.width = window.innerWidth,
            height = canvas.height = window.innerHeight;
        window.addEventListener('resize',function(){
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
        });
        document.body.appendChild(canvas);

        function randomWiggle(wiggle) {
          return (Math.random() * wiggle) * (Math.random() < 0.5 ? -1 : 1)
        }
        var color = -25;
        function randomColor() {
          color = Math.floor((color % 360) + 25 + 15 * Math.random());
          return cp.history[cp.history.length - 1]; // MODIFICATION
          //return 'hsl(' + color + ', 50%, 55%)';
        }

        function WaterColor(options) {
          if (!(this instanceof WaterColor)) { return new WaterColor(options); }
          for (var key in options) {
            if (options.hasOwnProperty(key)) { this[key] = options[key]; }
          }
          if (!this.fill) { this.fill = randomColor(); }
          this.c = Math.floor( Math.random() * 2 );
          this.render();
        }

        WaterColor.prototype = {
          sides: 6,
          x: 20,
          y: 20,
          ctx: false,
          speed: 0.3,
          maxPoints: 3000,
          maxRender: 5,
          scale: false,
          buildPoints() {
            var wiggle = this.size * 0.15,
                rotation = 0,
                x = -this.size, 
                y = 0,
                horizontal = Math.random() > 0.5,
                start = [ x, y ];
            this.points = [ start ];
            for (; rotation < twoPI; rotation += this.speed) {
              x += 
                this.size 
                * this.speed
                * Math.sin(rotation)
                * ( horizontal ? 1 : 0.7 )
                + randomWiggle( wiggle ); // * Math.cos( (rotation/twoPI) * twoPI ) );
              y += 
                this.size
                * this.speed
                * Math.cos(rotation)
                * ( horizontal ? 0.7 : 1 )
                + randomWiggle( wiggle );// * Math.cos( (rotation/twoPI) * twoPI) );
              this.points.push([ x, y ]);
            }
            this.points.push( start );
            this.originalPoints = this.points;
            return this.points;
          },
          expandPoints() {
            if (!this.points) { return this.buildPoints(); }
            if (this.points.length > this.maxPoints) { return false; }
            var wiggle = this.size * 0.05;
            var p = [],
                i = 0,
                len = this.points.length - 1,
                x, y, x2, y2;
            for ( ; i < len; i++) {
              y = this.points[i][1];
              x = this.points[i][0];
              y2 = this.points[i + 1][1];
              x2 = this.points[i + 1][0];
              p.push(
                [x, y],
                [(( x2 + x )/2) + randomWiggle(wiggle),  
                  (( y2 + y )/2) + randomWiggle(wiggle)],
                [x2, y2]
              );
            }
            this.points = p;
            return true;
          },
          c: 0,
          render: function(){
            this.c++;
            if ( this.c < (this.maxRender * 3) ) { requestAnimationFrame(this.render.bind(this)); }
            if ( this.c % 3 == 0 ) { this.draw(this.c / 3); }
          },
          draw: function(c) {
            if (this.ctx) {
              while ( this.expandPoints() ){}
              var ctx = this.ctx;
              var itr = (c/this.maxRender);
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.globalCompositeOperation = 'hard-light';// 'xor';
              ctx.globalAlpha = 0.25 - ( itr * 0.1 );
              ctx.translate( this.x, this.y );
              if (this.scale) { ctx.scale( 1 + itr * 0.2, 1 + itr * 0.2 ); }
              ctx.beginPath();
              ctx.moveTo(this.points[0][0], this.points[0][1]); //this.x + this.size, this.y);
              for (var i = 0, len = this.points.length; i < len; i++) {
                ctx.lineTo( this.points[i][0], this.points[i][1] );
              }
              ctx.closePath();
              ctx.fillStyle = this.fill;
              ctx.fill();
              this.points = this.originalPoints;
            }
            return this;
          }
        };

        var color = 0;
        function makeWatercolor(e){
          var x = width * Math.random(),
              y = height * Math.random();
          if (e) {
            e = e.touches ? e.touches[0] : e;
            x = e.clientX || e.x;
            y = e.clientY || e.y;
          }
          ctx.globalAlpha = 0.02;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = '#FFF';
          ctx.fillRect(0, 0, width, height);
          new WaterColor({
            ctx: ctx,
            size: Math.min(width,height) * ( 0.2 + Math.random() * 0.1 ),
            x: x,
            y: y,
            scale: true
          })
        }
        document.addEventListener('click', makeWatercolor );
        document.addEventListener('touchstart', makeWatercolor );

        var halfWidth = width / 2,
            halfHeight = height / 2
        for (var i = 0, len = 10; i < len; i++) {
          new WaterColor({
            ctx: ctx,
            size: width * ( 0.7 + Math.random() * 0.1 ),
            x: halfWidth + ( Math.cos( (i / len) * twoPI ) * halfWidth ), 
            y: halfHeight + ( Math.sin( (i / len) * twoPI ) * halfHeight ) 
          });
        }
    });
    // END CODEPEN CODE
      }
	</script>
</head>
  
  
<body>
  <canvas id="myCanvas" width="770px" height="770px"></canvas>
	<div id="color-palette"></div>
</body>
</html>
